diff --git a/pintos/src/examples/.gitignore b/pintos/src/examples/.gitignore
index a9e09d7..d5a1a73 100644
--- a/pintos/src/examples/.gitignore
+++ b/pintos/src/examples/.gitignore
@@ -17,3 +17,5 @@ lineup
 matmult
 recursor
 *.d
+*.o
+*.a
diff --git a/pintos/src/filesys/file.h b/pintos/src/filesys/file.h
index a33c5af..0f8673a 100644
--- a/pintos/src/filesys/file.h
+++ b/pintos/src/filesys/file.h
@@ -3,6 +3,7 @@
 
 #include "filesys/off_t.h"
 
+struct file;
 struct inode;
 
 /* Opening and closing files. */
diff --git a/pintos/src/threads/thread.c b/pintos/src/threads/thread.c
index 955ccdc..cf584db 100644
--- a/pintos/src/threads/thread.c
+++ b/pintos/src/threads/thread.c
@@ -13,6 +13,7 @@
 #include "threads/vaddr.h"
 #ifdef USERPROG
 #include "userprog/process.h"
+#include "lib/user/syscall.h"
 #endif
 
 /* Random value for struct thread's `magic' member.
@@ -206,6 +207,24 @@ thread_create (const char *name, int priority,
 
   intr_set_level (old_level);
 
+#ifdef USERPROG
+  /* Process Hierarchy. */
+  struct thread *cur = thread_current();
+  t->parent = cur;
+  list_push_back(&cur->child_list, &t->c_elem);
+
+  /* Initialize semaphore. */
+  sema_init(&t->exit_sema, 0);
+  sema_init(&t->load_sema, 0);
+
+  /* Initialize exit_status. */
+  t->exit_status = 0;
+  t->load_status = 0;
+
+  /* Initialize next_fd for FDT */
+  t->next_fd = 2;
+#endif
+
   /* Add to run queue. */
   thread_unblock (t);
 
@@ -292,6 +311,30 @@ thread_exit (void)
 
 #ifdef USERPROG
   process_exit ();
+  struct thread *cur = thread_current();
+  enum intr_level old_level;
+
+  sema_up(&cur->exit_sema);
+
+  /* Remove child_list */
+  while (!list_empty(&cur->child_list)) {
+    struct list_elem *fr = list_front(&cur->child_list);
+    struct thread *ch = list_entry(fr, struct thread, c_elem);
+    old_level = intr_disable();
+    list_remove (fr);
+    fr->prev = NULL;
+    fr->next = NULL;
+    if (ch->status == THREAD_BLOCKED)
+      thread_unblock(ch);
+    intr_set_level(old_level);
+  }
+
+  /* Wait until parent check status. */
+  old_level = intr_disable();
+  while (((&cur->c_elem)->prev != NULL) && ((&cur->c_elem)->next != NULL)) {
+    thread_block();
+  }
+  intr_set_level(old_level);
 #endif
 
   /* Remove thread from all threads list, set our status to dying,
@@ -468,6 +511,12 @@ init_thread (struct thread *t, const char *name, int priority)
   strlcpy (t->name, name, sizeof t->name);
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
+
+#ifdef USERPROG
+  t->parent = NULL;
+  list_init(&t->child_list);
+#endif
+
   t->magic = THREAD_MAGIC;
   list_push_back (&all_list, &t->allelem);
 }
diff --git a/pintos/src/threads/thread.h b/pintos/src/threads/thread.h
index 7965c06..f0fbcfb 100644
--- a/pintos/src/threads/thread.h
+++ b/pintos/src/threads/thread.h
@@ -4,6 +4,8 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
+#include "filesys/file.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -96,6 +98,23 @@ struct thread
 #ifdef USERPROG
     /* Owned by userprog/process.c. */
     uint32_t *pagedir;                  /* Page directory. */
+
+    /* Process Hierarchy */
+    struct thread *parent;		/* Pointing to parent process. */
+    struct list child_list;		/* List of child processes. */
+    struct list_elem c_elem;		/* List element for siblings. */
+
+    /* Semaphore for exit and load. */
+    struct semaphore exit_sema;		/* Semaphore for exit. */
+    struct semaphore load_sema;		/* Semaphore for load. */
+
+    int exit_status;			/* Exit_status.  */
+    int load_status;			/* Load_status. */
+
+    /* File descriptor table. */
+    struct file *fdt[65];		/* Pointing FD table. */
+    int next_fd;			/* Next smallest FD */
+    struct file *running_file;		/* File pointer for running file. */
 #endif
 
     /* Owned by thread.c. */
diff --git a/pintos/src/userprog/exception.c b/pintos/src/userprog/exception.c
index 19aca12..83fa175 100644
--- a/pintos/src/userprog/exception.c
+++ b/pintos/src/userprog/exception.c
@@ -4,6 +4,7 @@
 #include "userprog/gdt.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "lib/user/syscall.h"
 
 /* Number of page faults processed. */
 static long long page_fault_cnt;
@@ -148,6 +149,9 @@ page_fault (struct intr_frame *f)
   write = (f->error_code & PF_W) != 0;
   user = (f->error_code & PF_U) != 0;
 
+  /* Modify page_fault() for test */
+  exit(-1);
+
   /* To implement virtual memory, delete the rest of the function
      body, and replace it with code that brings in the page to
      which fault_addr refers. */
diff --git a/pintos/src/userprog/process.c b/pintos/src/userprog/process.c
index c0e5215..7a4dd33 100644
--- a/pintos/src/userprog/process.c
+++ b/pintos/src/userprog/process.c
@@ -8,6 +8,7 @@
 #include "userprog/gdt.h"
 #include "userprog/pagedir.h"
 #include "userprog/tss.h"
+#include "userprog/syscall.h"
 #include "filesys/directory.h"
 #include "filesys/file.h"
 #include "filesys/filesys.h"
@@ -20,6 +21,85 @@
 
 static thread_func start_process NO_RETURN;
 static bool load (const char *cmdline, void (**eip) (void), void **esp);
+void argument_stack (char **, int, void **);
+
+
+/* Set-up stack for starting user process. Push arguments,
+   push argc and argv, and push the address of the next
+   instruction. This function is used in start_process. */
+void
+argument_stack (char **argv, int argc, void **esp_)
+{
+  void *esp = *esp_;
+  char *arg_addr[argc];
+  /* Push arguments in argv */
+  int i, j;
+  for (i = argc-1; i >= 0; i--) {
+    for (j = strlen(argv[i]); j >= 0; j--) {
+      esp--;
+      *(char *)esp = argv[i][j];
+    }
+    arg_addr[i] = esp;
+  }
+  /* Place padding to align esp by 4 Byte */
+  while (((int)esp % 4) != 0) {
+    esp--;
+    *(char *)esp = 0;
+  }
+  /* Push start address of argv */
+  for (i = argc; i >= 0; i--) {
+    esp = esp - sizeof(char *);
+    if (i == argc) {
+      *(char **)esp = NULL;
+    }
+    else {
+      *(char **)esp = arg_addr[i];
+    }
+  }
+
+  /* Push argc and argv */
+  esp = esp -sizeof(char **);
+  *(char ***)esp = (char **)(esp + sizeof(char **));
+
+  esp = esp - sizeof(int *);
+  *(int *)esp = argc;
+
+  /* Push the address of the next instruction */
+  esp = esp - sizeof(void **);
+  *(void **)esp = NULL;
+
+  /* Update esp */
+  *esp_ = esp;
+}
+
+/* Get child process of current running thread with tid.
+   If not exists, return NULL */
+struct thread *
+get_child_process (tid_t tid)
+{
+  if (tid == TID_ERROR) {
+    return NULL;
+  }
+  struct thread *child;
+  struct list_elem *iter;
+  if (list_empty(&thread_current()->child_list))
+    return NULL;
+
+  iter = list_front(&thread_current()->child_list);
+  while (iter != NULL) {
+    child = list_entry(iter, struct thread, c_elem);
+    if (child->tid == tid) {
+      break;
+    }
+    iter = list_next(iter);
+  }
+
+  /* If child_tid is not found. */
+  if (iter == NULL) {
+    return NULL;
+  }
+  return child;
+}
 
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
@@ -38,10 +118,18 @@ process_execute (const char *file_name)
     return TID_ERROR;
   strlcpy (fn_copy, file_name, PGSIZE);
 
+  /* Parse the file_name.
+     Deliver the first argument of it to thread_create below */
+  char *save_ptr;
+  char *cmd_line = palloc_get_page(0);
+  strlcpy (cmd_line, file_name, PGSIZE);
+  char *token = strtok_r(cmd_line, " ", &save_ptr);
+
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
+  tid = thread_create (token, PRI_DEFAULT, start_process, fn_copy);
   if (tid == TID_ERROR)
     palloc_free_page (fn_copy); 
+  palloc_free_page (cmd_line);
   return tid;
 }
 
@@ -59,12 +147,45 @@ start_process (void *file_name_)
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
-  success = load (file_name, &if_.eip, &if_.esp);
+
+  /* Count argc */
+  int count = 0;
+  char *iter = (char *)file_name;
+  while (*iter != '\0') {
+    if (*iter == ' ') {
+      count++;
+      while (*(iter+1) == ' ')
+        iter++;
+    }
+    iter++;
+  }
+  count++;
+
+  /* Parse arguments */
+  char *parse[count];
+  char *token;
+  char *save_ptr;
+  int i = 0;
+  for (token = strtok_r(file_name, " ", &save_ptr);
+       token != NULL; token = strtok_r(NULL, " ", &save_ptr)) {
+    parse[i] = token;
+    i++;
+  }
+  count = i;
+  success = load (parse[0], &if_.eip, &if_.esp);
 
   /* If load failed, quit. */
+  if (!success) {
+    thread_current()->load_status = -1;
+    sema_up(&thread_current()->load_sema);
+    palloc_free_page (file_name);
+    exit(-1);
+  }
+  argument_stack(parse, count, &if_.esp);
+  //hex_dump((uintptr_t) if_.esp, if_.esp, PHYS_BASE - if_.esp, true);
   palloc_free_page (file_name);
-  if (!success) 
-    thread_exit ();
+  thread_current()->load_status = 0;
+  sema_up(&thread_current()->load_sema);
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -86,9 +207,22 @@ start_process (void *file_name_)
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
 int
-process_wait (tid_t child_tid UNUSED) 
+process_wait (tid_t child_tid)
 {
-  return -1;
+  struct thread *child = get_child_process(child_tid);
+  enum intr_level old_level;
+
+  if (child == NULL)
+    return -1;
+
+  sema_down(&child->exit_sema);
+  old_level = intr_disable ();
+  list_remove(&child->c_elem);
+  child->c_elem.prev = NULL;
+  child->c_elem.next = NULL;
+  thread_unblock(child);
+  intr_set_level (old_level);
+  return child->exit_status;
 }
 
 /* Free the current process's resources. */
@@ -97,7 +231,14 @@ process_exit (void)
 {
   struct thread *cur = thread_current ();
   uint32_t *pd;
-
+  int i;
+  for (i=2; i<64; i++){
+    if (cur->fdt[i] != NULL) {
+      file_close(cur->fdt[i]);
+      cur->fdt[i] = NULL;
+    }
+  }
+  file_close(cur->running_file);
   /* Destroy the current process's page directory and switch back
      to the kernel-only page directory. */
   pd = cur->pagedir;
@@ -221,14 +362,18 @@ load (const char *file_name, void (**eip) (void), void **esp)
     goto done;
   process_activate ();
 
+  lock_acquire(&filesys_lock);
   /* Open executable file. */
   file = filesys_open (file_name);
   if (file == NULL) 
     {
+      lock_release(&filesys_lock);
       printf ("load: %s: open failed\n", file_name);
       goto done; 
     }
-
+  file_deny_write (file);
+  thread_current()->running_file = file;
+  lock_release(&filesys_lock);
   /* Read and verify executable header. */
   if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
       || memcmp (ehdr.e_ident, "\177ELF\1\1\1", 7)
@@ -312,7 +457,10 @@ load (const char *file_name, void (**eip) (void), void **esp)
 
  done:
   /* We arrive here whether the load is successful or not. */
-  file_close (file);
+  if (!success) {
+    file_close (file);
+    thread_current()->running_file = NULL;
+  }
   return success;
 }
 
diff --git a/pintos/src/userprog/process.h b/pintos/src/userprog/process.h
index 688cd2a..569ca1a 100644
--- a/pintos/src/userprog/process.h
+++ b/pintos/src/userprog/process.h
@@ -3,6 +3,8 @@
 
 #include "threads/thread.h"
 
+struct thread * get_child_process (tid_t);
+
 tid_t process_execute (const char *file_name);
 int process_wait (tid_t);
 void process_exit (void);
diff --git a/pintos/src/userprog/syscall.c b/pintos/src/userprog/syscall.c
index 370c89b..38112bf 100644
--- a/pintos/src/userprog/syscall.c
+++ b/pintos/src/userprog/syscall.c
@@ -1,20 +1,258 @@
+#include "devices/shutdown.h"
+#include "devices/input.h"
 #include "userprog/syscall.h"
+#include "userprog/process.h"
 #include <stdio.h>
 #include <syscall-nr.h>
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "filesys/filesys.h"
+#include "threads/synch.h"
+#include "lib/string.h"
 
+
+/* function prototypes */
 static void syscall_handler (struct intr_frame *);
 
+/* Check if input is user address */
+bool
+is_user_address (void *addr)
+{
+  return ((uint32_t) addr >= 0x8048000) && ((uint32_t)addr <= 0xbffffffb);
+}
+
 void
 syscall_init (void) 
 {
   intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
+  lock_init(&filesys_lock);
+}
+
+/* System call handler functions - Process related */
+void
+halt (void)
+{
+  /* Shutdown Pintos. */
+  shutdown_power_off();
+}
+
+void
+exit (int status)
+{
+  struct thread *cur = thread_current();
+
+  /* Save exit status at process descriptor */
+  cur->exit_status = status;
+  printf("%s: exit(%d)\n", cur->name, status);
+  thread_exit();
+}
+
+pid_t
+exec (const char *cmd_line)
+{
+  /* Create child process and execute program */
+  if (!is_user_address((void *)cmd_line))
+    exit (-1);
+
+  tid_t tid = process_execute(cmd_line);
+  struct thread *child = get_child_process(tid);
+  if (child == NULL)
+    return -1;
+  sema_down(&child->load_sema);
+
+  if (child->load_status == 0)
+    return tid;
+  else
+    return -1;
+}
+
+int
+wait (pid_t pid)
+{
+  /* Wait for termination of child process whose process id is pid */
+  return process_wait(pid);
+}
+
+/* System call handler functions - File related */
+bool
+create (const char *file, unsigned initial_size)
+{
+  /* Create file which have size of initial_size
+     Use bool filesys_create(const char *name, off_t initial_size) */
+  if (!is_user_address((void *)file))
+    exit(-1);
+
+  return filesys_create(file, initial_size);
+}
+
+bool
+remove (const char *file)
+{
+  /* Remove file whose name is file
+     Use bool filesys_remove(const char *name) */
+  return filesys_remove(file);
+}
+
+int
+open (const char *file)
+{
+  /* Open the file corresponds to path in file
+     Use struct file *filesys_open(const char *name) */
+  if (!is_user_address((void *)file))
+    exit(-1);
+  struct thread *cur = thread_current();
+  if (cur->next_fd == 64)
+    return -1;
+
+  struct file *f = filesys_open(file);
+  if (f == NULL)
+    return -1;
+  cur->fdt[cur->next_fd] = f;
+  int fd = cur->next_fd;
+  while (cur->fdt[cur->next_fd] != NULL) {
+    cur->next_fd++;
+  }
+  return fd;
+}
+
+int
+filesize(int fd)
+{
+  /* Return the size, in bytes, of the file open as fd
+     Use off_t file_length(struct file *file) */
+  return (int) file_length(thread_current()->fdt[fd]);
+}
+
+int
+read (int fd, void *buffer, unsigned size)
+{
+  /* Use uint8_t input_getc(void) for fd = 0, otherwise
+     use off_t file_read(struct file *file, void *buffer, off_t size) */
+
+  if (!is_user_address(buffer))
+    exit(-1);
+  lock_acquire(&filesys_lock);
+  if (fd == 0)
+    return input_getc();
+  else
+    return (int) file_read(thread_current()->fdt[fd], buffer, size);
+
+}
+
+int
+write (int fd, const void *buffer, unsigned size)
+{
+  /* Use void putbuf(const char *buffer, size_t n) for fd = 1, otherwise
+     use off_t file_write(struct file *file, const void *buffer, off_t size) */
+  if (!is_user_address((void *)buffer))
+    exit(-1);
+  lock_acquire(&filesys_lock);
+  if (fd == 1) {
+    putbuf((char *)buffer, size);
+    return size;
+  }
+  else {
+    return file_write(thread_current()->fdt[fd], (char *)buffer, size);
+  }
+}
+
+void
+seek (int fd, unsigned position)
+{
+  /* Changes the next byte to be read or written in open file fd to position
+     Use void file_seek(struct file *file, off_t new_pos */
+  return file_seek(thread_current()->fdt[fd], position);
+}
+
+unsigned
+tell (int fd)
+{
+  /* Return the position of next byte to be read or written in open file fd
+     Use off_t file_tell(struct file *file) */
+  return file_tell(thread_current()->fdt[fd]);
+}
+
+void
+close (int fd)
+{
+  /* Use void file_close(struct file *file) */
+  struct thread *cur = thread_current();
+  if (cur->fdt[fd] != NULL) {
+    file_close(cur->fdt[fd]);
+    cur->fdt[fd] = NULL;
+    if (fd < cur->next_fd)
+      cur->next_fd = fd;
+  }
 }
 
+/* Actual System call hander call System call */
 static void
-syscall_handler (struct intr_frame *f UNUSED) 
+syscall_handler (struct intr_frame *f)
 {
-  printf ("system call!\n");
-  thread_exit ();
+  void *esp = f->esp;
+  int number = *(int *)esp;
+  if (!is_user_address(esp))
+    exit(-1);
+
+  /* System Call */
+  switch (number) {
+    /* Process related system calls */
+    case SYS_HALT:
+      halt();
+      break;
+
+    case SYS_EXIT:
+      exit(*((int *)esp + 1));
+      break;
+
+    case SYS_EXEC:
+      f->eax = exec(*((char **)esp + 1));
+      break;
+
+    case SYS_WAIT:
+      f->eax = wait(*((int *)esp + 1));
+      break;
+
+    /* File related system calls */
+    case SYS_CREATE:
+      f->eax = create(*((char **)esp + 1), *((int *)esp + 2));
+      break;
+
+    case SYS_REMOVE:
+      f->eax = remove(*((char **)esp + 1));
+      break;
+
+    case SYS_OPEN:
+      f->eax = open(*((char **)esp + 1));
+      break;
+
+    case SYS_FILESIZE:
+      f->eax = filesize(*((int *)esp +1));
+      break;
+
+    case SYS_READ:
+      f->eax = read(*((int *)esp + 1), *((void **)esp + 2), *((int *)esp +3));
+      lock_release(&filesys_lock);
+      break;
+
+    case SYS_WRITE:
+      f->eax = write(*((int *)esp+1), *((char **)esp+2), *((int *)esp+3));
+      lock_release(&filesys_lock);
+      break;
+
+    case SYS_SEEK:
+      seek(*((int *)esp +1), *((int *)esp + 2));
+      break;
+
+    case SYS_TELL:
+      f->eax = tell(*((int *)esp +1));
+      break;
+
+    case SYS_CLOSE:
+      close(*((int *)esp + 1));
+      break;
+
+    default:
+      break;
+  }
 }
diff --git a/pintos/src/userprog/syscall.h b/pintos/src/userprog/syscall.h
index 9059096..941c29c 100644
--- a/pintos/src/userprog/syscall.h
+++ b/pintos/src/userprog/syscall.h
@@ -3,4 +3,24 @@
 
 void syscall_init (void);
 
+typedef int pid_t;
+
+struct lock filesys_lock;
+
+bool is_user_address(void *);
+void halt(void);
+void exit(int);
+pid_t exec(const char *);
+int wait(pid_t);
+bool create(const char *, unsigned);
+bool remove(const char *);
+int open(const char *);
+int filesize(int);
+int read(int, void *, unsigned);
+int write(int, const void *, unsigned);
+void seek(int, unsigned);
+unsigned tell(int);
+void close(int);
+
+
 #endif /* userprog/syscall.h */
diff --git a/pintos/src/utils/pintos-gdb b/pintos/src/utils/pintos-gdb
index 4ef38d3..4eb7d65 100755
--- a/pintos/src/utils/pintos-gdb
+++ b/pintos/src/utils/pintos-gdb
@@ -1,7 +1,8 @@
 #! /bin/sh
 
 # Path to GDB macros file.  Customize for your site.
-GDBMACROS=/usr/class/cs140/pintos/pintos/src/misc/gdb-macros
+#GDBMACROS=/usr/class/cs140/pintos/pintos/src/misc/gdb-macros
+GDBMACROS=$HOME/pintos-team3/pintos/src/misc/gdb-macros
 
 # Choose correct GDB.
 if command -v i386-elf-gdb >/dev/null 2>&1; then
